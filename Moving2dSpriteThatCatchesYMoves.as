package com{	import com.Moving2dSpriteThatCatches;	import flash.utils.Timer;//for timer	import flash.display.*;	import flash.events.*;	import flash.text.TextField;	public class Moving2dSpriteThatCatchesYMoves extends Moving2dSpriteThatCatches {		private var movingCounter:Timer;		private var moverXPos:Number;		private var moverYPos:Number;		private var isHomeLap:Boolean = false;		//main		//GREAT SO HAVE number of pixels to move on every timer event: PIXELSMOVEDONTICK		private var MOVETIMES:Number;			//INCREASE TO INCREASE SPEED OF MOVEMENT		private var MSECTOTALOFTIMER:Number = 100 * 1000;  //INCREASE  TO INCREASE TIME OF MOVEMENT		private var MSECBETWEENTIMERTICK:Number = 1 * 1000;		private var NUMBERTICKSTOTAL:Number = MSECTOTALOFTIMER / MSECBETWEENTIMERTICK;		private var SPRITEW:Number = 90;//not of your character, but of what your character is put into		private var RECTW:Number= 150;//not the stage height, but the height of the rectangle SPRITEW's centerpoint moves in		private var DISTANCENEEDEDTOTRAVEL:Number;		//to move MOVETIMES how much distance in pixels is needed to move on every timer event?		private var PIXELSMOVEDONTICK:Number;		//location of container sprite will move in		private var MOVERINITIALXFIELD:Number= 0;		private var MOVERINITIALYFIELD:Number= 0;		private var moverFieldContainer:Sprite = new Sprite();		//timer, sprite, degree, velocity, gravity		public function Moving2dSpriteThatCatchesYMoves(aTimer:Timer,obj:Sprite,d:Number=20, v:Number=40,g:Number=9.8, movetimes:Number=10 ):void {			//send stuff up			MOVETIMES = movetimes;			DISTANCENEEDEDTOTRAVEL = RECTW*MOVETIMES;			PIXELSMOVEDONTICK = DISTANCENEEDEDTOTRAVEL/ NUMBERTICKSTOTAL;			moverFieldContainer = new Sprite();			moverFieldContainer.x=MOVERINITIALXFIELD;			moverFieldContainer.y=MOVERINITIALYFIELD;			moverFieldContainer.addChild(obj);						//			trace("mover created to move :)"+PIXELSMOVEDONTICK+" pixels ");									//set up timer			moverXPos = 0;//zero  actual sprite pos moverXPos + MOVERINITIALXFIELD			moverYPos = 0;//zero												movingCounter = new Timer(MSECBETWEENTIMERTICK,NUMBERTICKSTOTAL);			movingCounter.addEventListener(TimerEvent.TIMER, moverMove);			movingCounter.addEventListener(TimerEvent.TIMER_COMPLETE, moverStop);						//start motion			movingCounter.start();									/*			//using the existing timer			movingCounter = new Timer(aTimer.delay,aTimer.repeatCount);			movingCounter.addEventListener(TimerEvent.TIMER, moverMove);			movingCounter.addEventListener(TimerEvent.TIMER_COMPLETE, moverStop);			*/						//WHY DOES IT SEND aTimer and not movingCounter, does it have to do with the Collider???			super(aTimer,moverFieldContainer,d, v, g);					}		//accessor set methods		private function moverMove(event:TimerEvent):void{			setMoverPosition();			//trace("moverYpos :)"+ moverYPos);			moverFieldContainer.x = moverXPos + MOVERINITIALXFIELD;			moverFieldContainer.y = moverYPos + MOVERINITIALYFIELD;		}		private function moverStop(event:TimerEvent):void{			movingCounter.stop();		}						private function setMoverPosition():void{			trace("moverYpos :)"+ moverYPos);			if(!isHomeLap){			if( moverYPos < RECTW){				moverYPos = moverYPos + PIXELSMOVEDONTICK;			}			else if(moverYPos >= RECTW){				isHomeLap = true;			}			}			else{				if( moverYPos >= 0){				moverYPos = moverYPos - PIXELSMOVEDONTICK;			}			else if(moverYPos < 0){				isHomeLap = false;			}							}					}				//accessor get method		public function startMoverTimerAndMove():void{			movingCounter.start();		}				public function moverYPosition():Number{return moverYPos;};		public function moverXPosition():Number{return moverXPos;};	}}